Two pointers used problems:
================================

**1.Reverse string in that use a while loop simple

reverse(arr)
{
    let start = 0; let end = arr.length -1;

    while(start<end)
    {
        //swap
        [arr[start], arr[end]] = [arr[end], arr[start]];
        start++;
        end--
    }
    return arr;
}
=============================================================
**2. Move zeros to end/begin (NOte* zeros to end or beginning)

move(arr) //to end [0,1,0,2,0,5,6,0]
{
//two pointers
let left = 0;
for(let right=0; right< arr.length; right++)
{
    if(arr[right]!== 0)
    {
        arr[left] = arr[right];
        left++;
    }
}
//after this loop [1,2,3,6,0,5,6,0]
//now want to make all others zer from left to end
 while(left < arr.length)
 {
    arr[left] = 0; //fill with zeros
    left++;
 }
}

move(arr) //to Start [0,1,0,2,0,5,6,0]
{
//two pointers
let pos = arr.length - 1;
for(let right =arr.length - 1; right>=0; right--)
{
    if(arr[right]!== 0)
    {
        arr[pos] = arr[right];
        pos--;
    }
}
//afte this loop [0,1,0,2,1,2,5,6]
//now want to make all others zeros from beginning to pos
while(pos >= 0)
{
    arr[pos] = 0; //fill with zeros
    pos--;
}
}
=========================================================
3.Move +ve to left -ve to right // even to left odd to right //
In this case need two pointers but we need swapping like reverese array because we dont need to fill remainiong with 0s.OR you can use blow solution of swapping for moving 0 to end instead of filling with zeros. in this case take one as poitive case which you need to move to left in example above take +ve as condition because you want that uin left side

moveLeftNumbers(arr) //to end [1,2,-1,-3,-6,7,8]
{
//two pointers
let left = 0;
for(let right=0; right< arr.length; right++)
{
    if(arr[right] > 0)
    {
        [arr[left],arr[right]] = [arr[right],arr[left]];
        left++;
    }
}
}
===============================================================
4.remove duplicates from sorted array
2 pointers compare left !== right then first left++ then left=right
======================================
5.dutch flag or sort any particular strings like colrs [red, yelow, blue]
OR any dynamic elements sort them
if intervierer ok with map go for it as first solution otherwise go foir pointer
Solution 1: MAP-> count each occurances and have a map then loop through keys and fill it
Solution 2(if only 3 elements unique(>3 Categories:Fails)): three pointers.- low, mid, high -> this can be used if array has numbers or strings
low -> starts at 0(boundary for 1st number/string)-> first set appear after sort
mid -> the current num/string scanned(atart at 0) -> second set
high-> boundary of last element in array -> 3rd set

Use the POINTER Approach if:
-You have exactly 2 or 3 fixed categories (e.g., Even/Odd, Zeros/Ones, Red/White/Blue).
-The interviewer says "O(1) space" or "In-place only".
-The array contains Objects that you cannot recreate
Use the MAP Approach if:
-The categories are Dynamic (you don't know the names or how many there are).
-You need to maintain Alphabetical order of the groups.
-You want the most readable code that is hard to break with "off-by-one
//

